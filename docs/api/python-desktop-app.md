# API Documentation: Python Desktop Print Service (Flask Backend)

This document describes the API endpoints exposed by the Python Flask application designed to act as a print service and **serve the static Label Vision Next.js web application**.

## Base URL

The Python application runs a local web server. When running locally or in Docker, it typically listens on:

`http://localhost:5001`

(This port can be configured via the `FLASK_RUN_PORT` environment variable).

## Serving the Web Application

*   The Flask application is configured to serve the static files generated by the Next.js build (`npm run build`, which outputs to the `out/` directory).
*   It serves `out/index.html` for the root path (`/`) and any other non-API path, allowing the Next.js client-side router to handle navigation.
*   Static assets like CSS, JavaScript, and images located within `out/_next/static/` are served directly by Flask under the `/` path.

## API Endpoints (Prefixed with `/api`)

All backend API endpoints are prefixed with `/api` to distinguish them from the frontend routes.

### 1. Health Check

*   **Endpoint:** `/api/health`
*   **Method:** `GET`
*   **Purpose:** Allows the Next.js frontend (running in the browser, served by this Flask app) to check if the Python print service *backend* is running and reachable.
*   **Request Body:** None
*   **Responses:**
    *   **`200 OK`**:
        *   **Content:** `application/json`
        *   **Body:** `{ "status": "ok", "platform": "windows|linux|darwin", "printer_lib": "win32|cups|none" }`
        *   **Description:** The service is running and healthy. Includes basic platform info.
    *   **(Implicit) Connection Error:** If the Next.js app cannot connect to this endpoint (e.g., `fetch` fails), it indicates a server issue or network problem.

### 2. Get Available Printers

*   **Endpoint:** `/api/printers`
*   **Method:** `GET`
*   **Purpose:** Retrieves a list of printer names known to the system where the Python application is running.
*   **Request Body:** None
*   **Responses:**
    *   **`200 OK`**:
        *   **Content:** `application/json`
        *   **Body:** `["Printer Name 1", "Microsoft Print to PDF", "My Label Printer ZT410"]` (Example)
        *   **Description:** Successfully retrieved the list of available printer names as an array of strings. The list might be empty if no printers are found or accessible.
    *   **`500 Internal Server Error`**:
        *   **Content:** `application/json`
        *   **Body:** `{ "detail": "Error message describing the failure" }`
        *   **Description:** An error occurred on the Python server while trying to list printers (e.g., issues with `win32print` or `pycups`, CUPS service down).

### 3. Print Label

*   **Endpoint:** `/api/print`
*   **Method:** `POST`
*   **Purpose:** Receives label data (as a PDF) and sends it to the specified printer.
*   **Request Body:**
    *   **Content-Type:** `application/json`
    *   **Schema:**
        ```typescript
        {
          pdfData: string; // Required: The generated PDF content, encoded as a Base64 string.
          printerName: string; // Required: The exact name of the target printer (must match one from the /api/printers list).
          labelSummary?: string; // Optional: A short summary for the print job name.
          // Optional: Add other print job options here if needed in the future
        }
        ```
    *   **Example:**
        ```json
        {
          "pdfData": "JVBERi0xLjcKJeLjz9MKMSAwIG9iago8PCAvVHlwZSAvQ2F0YW...", // Truncated Base64 PDF data
          "printerName": "My Label Printer ZT410",
          "labelSummary": "Sample Items"
        }
        ```
*   **Responses:**
    *   **`200 OK`**:
        *   **Content:** `application/json`
        *   **Body:** `{ "message": "Print job sent successfully to [Printer Name]" }`
        *   **Description:** The print job was successfully submitted to the OS printing system for the specified printer. **Note:** This usually means the job was *queued*, not necessarily that it physically printed without error.
    *   **`400 Bad Request`**:
        *   **Content:** `application/json`
        *   **Body:** `{ "detail": "Invalid payload: Missing required field 'pdfData'" }` or `{ "detail": "Invalid Base64 encoding for pdfData" }` or similar validation error.
        *   **Description:** The request body was malformed or missing required fields.
    *   **`404 Not Found`**:
        *   **Content:** `application/json`
        *   **Body:** `{ "detail": "Printer not found: [Printer Name]" }`
        *   **Description:** The specified `printerName` does not match any printer known to the system or accessible by the service.
    *   **`500 Internal Server Error`**:
        *   **Content:** `application/json`
        *   **Body:** `{ "detail": "Error message describing the printing failure" }`
        *   **Description:** An error occurred during the printing process on the server (e.g., communication error with the printer spooler, invalid PDF data *after* decoding, permission issues).

### 4. Notify Status (Optional - Python -> Separate Service)

*   **Endpoint:** `http://localhost:9002/api/print-status` (Example: Separate Next.js instance if *not* serving frontend from Flask)
*   **Method:** `POST`
*   **Purpose:** Allows the Python application to send the final status (success/failure) of a print job back to *another* application (e.g., if Next.js were running independently). **This is generally NOT used when Flask serves the Next.js frontend**, as feedback mechanisms would typically be handled differently (e.g., polling, WebSockets if implemented).
*   **Request Body:** (See `docs/api/print-status.md` for the schema expected by the *other* Next.js app)
    ```json
    {
      "jobId": "optional-job-id", // Optional
      "status": "success", // or "error"
      "message": "Printed successfully.", // Optional
      "printerName": "My Label Printer ZT410" // Optional
    }
    ```

## Security Considerations

*   **CORS:** CORS is handled by Flask (`Flask-Cors`) for the `/api/*` routes. Since the frontend is served from the same origin (`http://localhost:5001`), CORS is generally not an issue for frontend-backend communication within this setup.
*   **Network Access:** The Flask application listens on a specific host and port (e.g., `127.0.0.1:5001` locally, `0.0.0.0:5001` in Docker). Ensure firewalls allow access to this port if accessing from other machines (relevant for Docker deployments).
*   **Authentication:** No authentication is implemented by default. For production or shared environments, consider adding API key checks or other authentication mechanisms to the `/api/*` endpoints.
*   **File System Access:** The application needs read access to the Next.js build output (`out/`) and potentially write access to temporary directories (`tempfile`). Ensure appropriate permissions.
*   **Printing Permissions:** The user account running the Python Flask process needs permission to access and print to the selected system printers. This can be a consideration in restricted environments or when running as a different user/service.